import path from 'path';

export interface LicensePayload {
    customerName: string;
    type: 'COMMUNITY' | 'STARTER' | 'PRO' | 'ENTERPRISE';
    maxProductLines: number;
    maxUsers?: number;
    expiresAt: string;
}

export interface VerificationResult {
    valid: boolean;
    claims?: LicensePayload;
    error?: string;
}

declare const __non_webpack_require__: any;

// Cache the loaded module
let wasmModule: any = null;

export function verifyLicenseWithWasm(token: string): VerificationResult {
    if (!wasmModule) {
        try {
            // Resolve path to the pkg directory generated by wasm-pack
            // In a standard Next.js server runtime, process.cwd() is the project root.
            const pkgPath = path.join(process.cwd(), 'native/license-verifier/pkg/license_verifier.js');

             
            // Use eval('require') or similar to bypass Webpack/Turbopack static analysis 
            // since we want runtime resolution from filesystem.
            const dynamicRequire = typeof __non_webpack_require__ !== 'undefined' ? __non_webpack_require__ : require;
            wasmModule = dynamicRequire(pkgPath);

            // console.log('[LicenseWASM] Module loaded successfully.');
        } catch (e) {
            console.error('[LicenseWASM] Failed to load WASM module:', e);
            // Fallback or critical failure? 
            // If the module is missing, we can't secure verification.
            return {
                valid: false,
                error: 'Security module missing. Please ensure native/license-verifier is built.'
            };
        }
    }

    try {
        // call verify_license form Rust
        const result = wasmModule.verify_license(token);
        return result as VerificationResult;
    } catch (e) {
        console.error('[LicenseWASM] Error during verification execution:', e);
        return { valid: false, error: 'Verification runtime error.' };
    }
}
